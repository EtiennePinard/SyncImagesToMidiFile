package com.ejrp

import com.ejrp.midi.StandardMidiFile
import com.ejrp.midiToImgVid.image.getBlackBufferedImage
import com.ejrp.midiToImgVid.midi.getNotesTicksFromStart
import com.ejrp.midiToImgVid.midi.getTimebaseFromFile
import com.ejrp.midiToImgVid.video.Dimensions
import com.ejrp.midiToImgVid.video.JavaCVFrame
import com.ejrp.midiToImgVid.video.JavaCVVideoWithAudio
import java.awt.Color
import java.awt.Font
import java.awt.image.BufferedImage
import java.io.File
import java.io.FileInputStream
import javax.imageio.ImageIO

// The following function was generated by ChatGPT
fun createImageWithWhiteText(
    text: String,
    width: Int,
    height: Int,
    font: Font
): BufferedImage {
    val image = BufferedImage(width, height, BufferedImage.TYPE_INT_RGB)
    val g = image.createGraphics()

    // Fill background with black
    g.color = Color.BLACK
    g.fillRect(0, 0, width, height)

    // Set font and color for the text
    g.font = font
    g.color = Color.WHITE

    // Center the text
    val fm = g.fontMetrics
    val textWidth = fm.stringWidth(text)
    val textHeight = fm.ascent
    val x = (width - textWidth) / 2
    val y = (height + textHeight) / 2

    g.drawString(text, x, y)
    g.dispose()

    return image
}

private val NOTE_NAMES = arrayOf("C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B")

const val GRADLE_RESOURCE_FOLDER_PATH = "src/main/resources"

fun main() {
    val totalStartTime = System.currentTimeMillis()

    val width = 720
    val height = 1280
    val fontSize = 400
    val formatName = "mp4"
    val audioPath = "$GRADLE_RESOURCE_FOLDER_PATH/ATSOL_Audio.mp3"
    val outputPath = "./example.mp4"

    var start = System.currentTimeMillis()
    print("Generating the images")

    val imageFolder = File("$GRADLE_RESOURCE_FOLDER_PATH/tmpImage")
    imageFolder.mkdir()
    // Creating the note name images
    for (noteName in NOTE_NAMES) {
        val image = createImageWithWhiteText(noteName, width, height, Font("Arial", Font.BOLD, fontSize))
        val outputFile = File("${imageFolder.absolutePath}/${noteName.replace("#", "Sharp")}.jpg")
        outputFile.createNewFile()
        ImageIO.write(image, "jpg", outputFile)
        image.flush()
    }
    // Creating the black picture and saving it
    val blackEndPhoto = getBlackBufferedImage(width, height)
    val blackImageFile = File("${imageFolder.absolutePath}/blackImg.jpg")
    blackImageFile.createNewFile()
    ImageIO.write(blackEndPhoto, "jpg", blackImageFile)
    blackEndPhoto.flush()

    println(" (${System.currentTimeMillis() - start} ms)")

    start = System.currentTimeMillis()
    print("Parsing the midi and calculating the video timebase")

    // We know that this midi file is a format 1 midi file
    val midiFile = StandardMidiFile.fromInputStream(FileInputStream("$GRADLE_RESOURCE_FOLDER_PATH/ATSOL_Melody.mid"))


    val timebaseInSecondPerMidiTicks = getTimebaseFromFile(midiFile)
    println(" (${System.currentTimeMillis() - start} ms)")

    start = System.currentTimeMillis()
    print("Setting the length of each image in the video")
    val ticksOfNoteOnFromStart = getNotesTicksFromStart(midiFile)

    val imageSyncFrames = ticksOfNoteOnFromStart.map { midiNote ->
        JavaCVFrame(
            "${imageFolder.absolutePath}/${NOTE_NAMES[midiNote.key.ordinal % 12].replace("#", "Sharp")}.jpg",
            midiNote.durationInMidiTicks.toDouble() * timebaseInSecondPerMidiTicks
        )
    }.toMutableList()
    // Adding the back image at the end
    imageSyncFrames[imageSyncFrames.lastIndex] = JavaCVFrame(blackImageFile.absolutePath, 0.1)

    println(" (${(System.currentTimeMillis() - start)} ms)")

    start = System.currentTimeMillis()
    println("Encoding the images into a video file...")

    JavaCVVideoWithAudio(
        Dimensions(width, height),
        timebaseInSecondPerMidiTicks,
        formatName,
        imageSyncFrames,
        audioPath
    ).writeToFile(outputPath)

    // We don't need those pictures anymore
    imageFolder.deleteRecursively()

    println("Finished encoding in ${(System.currentTimeMillis() - start) / 1000} seconds")
    println("DONE (${(System.currentTimeMillis() - totalStartTime) / 1000} seconds)")
}