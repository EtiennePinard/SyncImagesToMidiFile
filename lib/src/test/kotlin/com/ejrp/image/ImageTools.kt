package com.ejrp.image

import com.ejrp.midiToImgVid.image.convertToType
import com.ejrp.midiToImgVid.image.letterboxToSize
import com.ejrp.midiToImgVid.image.resize
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test
import java.awt.Color
import java.awt.image.BufferedImage
import java.io.File
import java.util.*
import javax.imageio.ImageIO

// Note: Test generated by ChatGPT and verified by a human afterward
class BufferedImageExtensionsTest {

    @Test
    fun `convertToType returns same image if already correct type`() {
        val image = BufferedImage(100, 100, BufferedImage.TYPE_INT_ARGB)
        val result = image.convertToType(BufferedImage.TYPE_INT_ARGB)

        assertSame(image, result, "Expected the same instance when converting to the same type")
    }

    @Test
    fun `convertToType returns new image with same size and content`() {
        val width = 50
        val height = 50
        val original = BufferedImage(width, height, BufferedImage.TYPE_INT_RGB)
        val red = Color.RED.rgb

        original.setRGB(10, 10, red)

        val converted = original.convertToType(BufferedImage.TYPE_INT_ARGB)

        assertNotSame(original, converted, "Expected a new instance for a different type")
        assertEquals(width, converted.width)
        assertEquals(height, converted.height)
        assertEquals(red, converted.getRGB(10, 10), "Pixel color should be preserved during conversion")
    }

    @Test
    fun `resize returns same image if already correct size`() {
        val image = BufferedImage(100, 100, BufferedImage.TYPE_INT_ARGB)
        val result = image.resize(100, 100)

        assertSame(image, result, "Expected the same instance when resizing to the same dimensions")
    }

    @Test
    fun `resize returns new image with correct size`() {
        val original = BufferedImage(200, 200, BufferedImage.TYPE_INT_ARGB)
        val resized = original.resize(100, 50)

        assertNotSame(original, resized, "Expected a new instance when resizing")
        assertEquals(100, resized.width)
        assertEquals(50, resized.height)
    }

    @Test
    fun `resize jpg images and save to output directory`() {
        val targetWidth = 1920
        val targetHeight = 1080

        modifyImages(
            { img, filename ->
                val resized = img.resize(targetWidth, targetHeight).convertToType(BufferedImage.TYPE_INT_RGB)

                assertEquals(targetWidth, resized.width, "Width mismatch for $filename")
                assertEquals(targetHeight, resized.height, "Height mismatch $filename")
                resized
            },
            "Resized"
        )
    }

    @Test
    fun `zoom in and letterbox jpg images and save to output directory`() {
        val targetWidth = 1920
        val targetHeight = 1080

        modifyImages(
            { img, filename ->
                val resized = img.letterboxToSize(targetWidth, targetHeight).convertToType(BufferedImage.TYPE_INT_RGB)

                assertEquals(targetWidth, resized.width, "Width mismatch for $filename")
                assertEquals(targetHeight, resized.height, "Height mismatch $filename")
                resized
            },
            "Letterboxed"
        )
    }

    private val inputDir = File("src/test/resources/input")
    private val outputDir = File("src/test/resources/output")

    private fun modifyImages(modifier: (img: BufferedImage, filename: String) -> BufferedImage, modifierName: String) {
        require(inputDir.exists()) { "Input directory does not exist: ${inputDir.absolutePath}" }

        if (!outputDir.exists()) {
            val created = outputDir.mkdirs()
            require(created) { "Failed to create output directory: ${outputDir.absolutePath}" }
        }

        val jpgFiles = inputDir.listFiles { file -> file.extension.lowercase() == "jpg" }
            ?: emptyArray()

        require(jpgFiles.isNotEmpty()) { "No .jpg files found in ${inputDir.absolutePath}" }

        for (file in jpgFiles) {
            val original: BufferedImage = ImageIO.read(file)

            val modified = modifier(original, file.name)

            val outputFile = File(outputDir, "${file.nameWithoutExtension}_${modifierName.lowercase()}.jpg")
            if (!outputFile.exists()) {
                outputFile.createNewFile()
            }
            require(outputFile.exists()) { "The output file ${outputFile.name} does not exist" }
            val written = ImageIO.write(modified, "jpg", outputFile)
            require(written) { "Failed to write $modifierName image to ${outputFile.absolutePath}" }

            println(
                "${
                    modifierName.replaceFirstChar {
                        if (it.isLowerCase()) it.titlecase(Locale.getDefault())
                        else it.toString()
                    }
                } " +
                        "and saved ${file.name} to output/${file.name}"
            )
        }
    }
}
